---
title: "smart scheduling"
author: "Jakob Richter"
date: "18.11.2015"
output: html_document
---

```{r batchJobs}
library(BatchExperiments)
library(data.table)
reg = loadRegistry("~/lido_nobackup/rambo")
reducer = function(job, res){
  res.dt = cbind(
    prob = job$prob.id,
    algo = job$algo.id,
    repl = job$repl,
    seed = job$seed,
    setNames(job$prob.pars, paste0("probpar.", names(job$prob.pars))),
    setNames(job$algo.pars, paste0("algopar.", names(job$algo.pars))),
    t(setNames(res$performance, paste0("test.", names(res$performance)))),
    tune.y = res$model$learner.model$opt.result$mbo.result$y,
    do.call(cbind, setNames(res$model$learner.model$opt.result$mbo.result$x, paste0("x.", names(res$model$learner.model$opt.result$mbo.result$x)))),
    as.data.frame(res$model$learner.model$opt.result$mbo.result$opt.path))
}
res.list = reduceResultsList(reg, fun = reducer)
res.dt = rbindlist(res.list, fill = TRUE)
head(res.dt)
```

```{r initial design the same?}
length(unique(res.dt[dob == 0 & probpar.fold == 1 & selected.learner == "classif.svm.radial", .SD[1,] ,by = algopar.config.name]$classif.svm.radial.gamma)) == 1
```

```{r laufzeiten einbauen}
res.dt[algopar.infill.crit.lcb.lambda == 2 & algopar.config.name == "r.s.lcb", algopar.config.name := "r.s.lcb.2"]
#naive laufzeitaddierung
res.dt[, ':='(cumsum.exec.time = cumsum(exec.time), cummin.y = cummin(y)), by = .(prob, algo, repl, probpar.fold, algopar.config.name)]
res.dt[, ':='(exec.timestamp.dob = as.integer(exec.timestamp) - min(exec.timestamp), cummin.y = cummin(y)), by = .(prob, algo, repl, probpar.fold, algopar.config.name, dob)]
#wie lange braucht ein dob-schritt
res.dt.dobs = res.dt[, list(dob.exec.time = max(exec.timestamp + as.integer(exec.time)) - min(exec.timestamp)), by = .(prob, algo, repl, probpar.fold, algopar.config.name, dob)]
#summiere dob schritte auf
res.dt.dobs[, dob.endtime := cumsum(dob.exec.time)]
res.dt = res.dt[res.dt.dobs, , on = c("prob", "algo", "repl", "probpar.fold", "algopar.config.name", "dob")]
```

Analyze runtimes
```{r}
end.res = res.dt[, .SD[.N,], by = .(prob, algo, repl, probpar.fold, algopar.infill.crit, algopar.multipoint.lcb.multiple, algopar.iters, algopar.multipoint.method, algopar.propose.points, algopar.schedule.method, algopar.schedule.priority.time, probpar.fold)]

g = ggplot(res.dt, aes(x = dob , y = y, color = selected.learner))
g = g + geom_point()
g = g + geom_hline(data = end.res, mapping = aes(yintercept = test.mmce, color = x.selected.learner), alpha = 0.5)
g = g + geom_text(data = end.res, mapping = aes(y = test.mmce, label = algopar.config.name), size = 4, color = "black")
g + facet_grid(probpar.fold~algopar.config.name)

g = ggplot(res.dt[dob >= 1], aes(x = exec.time, y = y, color = selected.learner, shape = dob == 0))
g + geom_point(alpha = 0.5) + facet_wrap(~algopar.config.name) + scale_shape_manual(values = c(16,1))
```

Performance
```{r}
g = ggplot(end.res, aes(x = algopar.config.name, y = cummin.y, fill = algopar.config.name))
g + geom_boxplot()

g = ggplot(end.res, aes(x = algopar.config.name, y = test.mmce, fill = algopar.config.name))
g + geom_boxplot()
```

Zeitverlauf
```{r}
g = ggplot(res.dt[dob >= 1], aes(y = cummin.y, x = cumsum.exec.time, color = algopar.config.name))
g + geom_line() + facet_wrap(~probpar.fold)
```

Scheduling Analyse
```{r}
#how it was planned
g = ggplot(res.dt[dob > 0 & probpar.fold == 5], aes(y = scheduled.on, x = dob.exec.timestamp.rel + scheduled.at, color = selected.learner))
g = g + geom_segment(aes(yend = scheduled.on, xend = dob.exec.timestamp.rel + scheduled.at + predicted.time))
g + facet_wrap(~algopar.config.name)
```

Paretofront
```{r}
#how it was planned
g = ggplot(end.res, aes(y = exec.time, x = test.mmce, color = algopar.config.name))
g = g + geom_point(size = 5) + facet_wrap(~probpar.fold)
g
```

```{r}
res.dt[algopar.config.name == "r.s.lcb" & probpar.fold == 6]
```
